from dash import callback, Output, Input, State, callback_context, Dash, html
import dash_table
import pandas as pd
import logging

app = Dash(__name__)

app.layout = html.Div([
    # Your layout components here...
    dash_table.DataTable(id='phrase-grid'),
    html.Div(id='formula-output')
])


@app.callback(
    Output("formula-output", "children"),
    Input("block-a-required", "checked"),
    Input("block-b-required", "checked"),
    Input("block-c-required", "checked"),
    Input("block-d-required", "checked"),
    Input("block-e-required", "checked"),
    Input("phrase-grid", "cellValueChanged"),
    State("phrase-grid", "data"),
    State("phrase-grid", "rowData"),
)
def formula_logic(block_a_required, block_b_required, block_c_required, 
                  block_d_required, block_e_required, phrase_grid_changes, 
                  phrase_grid_full_data, phrase_grid_data):

    ctx = callback_context
    triggered_id = ctx.triggered_id

    logging.info(f"Triggered ID: {triggered_id}")

    valid_ids = ["phrase-grid", "block-a-required", "block-b-required",
                 "block-c-required", "block-d-required", "block-e-required"]

    if triggered_id not in valid_ids:
        logging.info("Callback was not triggered by a valid input.")
        return dash.no_update

    # Convert grid data to DataFrame
    df_phrase_grid = pd.DataFrame(phrase_grid_data)
    logging.info(f"Phrase Grid: {df_phrase_grid}")

    # Check if DataFrame is empty or 'block_id' not in columns
    if df_phrase_grid.empty or 'block_id' not in df_phrase_grid.columns:
        return "No logic defined due to no data available"

    # Initialize lists to store block ids
    required_inclusion_blocks = []
    non_required_inclusion_blocks = []
    exclusion_blocks = []

    # Assume you define block_ids somewhere
    block_ids = [...]  # Define this based on your use case

    # Iterate through block ids to categorize them based on logic
    for block_id in block_ids:
        block_data = df_phrase_grid[df_phrase_grid['block_id'] == block_id]
        if block_data[block_data['phrase_operator'] == 'INCLUDE MATCHES'].shape[0] > 0 and block_data['block_combo_logic'].iloc[0]:
            required_inclusion_blocks.append(block_id)
        elif block_data[block_data['phrase_operator'] == 'INCLUDE MATCHES'].shape[0] > 0:
            non_required_inclusion_blocks.append(block_id)
        else:
            exclusion_blocks.append(block_id)

    # Create logic strings
    inclusion_str = ' ∩ '.join(required_inclusion_blocks)
    non_required_inclusion_str = ' U '.join(non_required_inclusion_blocks)

    if inclusion_str and non_required_inclusion_str:
        inclusion_str = f"{inclusion_str} ∩ {non_required_inclusion_str}"
    elif non_required_inclusion_str:
        inclusion_str = non_required_inclusion_str

    exclusion_str = ' ⊄ '.join(exclusion_blocks)

    # Construct the final output string
    if inclusion_str and exclusion_str:
        return f"({inclusion_str}) ⊄ {exclusion_str}"
    elif inclusion_str:
        return f"{inclusion_str}"
    elif exclusion_str:
        return f"⊄ {exclusion_str}"
    else:
        return "No logic defined"
