from dash import callback_context

# Your app and other imports here...

@callback(
    Output("formula-output", "children"),
    Input("phrase-grid", "cellValueChanged"),
    Input("phrase-grid", "data"),
    State("phrase-grid", "rowData"),
)
def formula_logic(phrase_grid_changes, phrase_grid_full_data, phrase_grid_data):
    # Get triggered id
    ctx = callback_context
    triggered_id = ctx.triggered_id

    # Log triggered id
    logging.info(f"Triggered ID: {triggered_id}")
    
    try:
        # Convert grid data to DataFrame
        df_phrase_grid = pd.DataFrame(phrase_grid_data)
        logging.info(f"Phrase Grid: {df_phrase_grid}")
        
        # Check if DataFrame is empty or 'block_id' not in columns
        if df_phrase_grid.empty or 'block_id' not in df_phrase_grid.columns:
            return "No logic defined due to no data available"

	# Ensuring callback logic executes only when the phrase-grid is changed
        if "phrase-grid.cellValueChanged" in triggered_id and phrase_grid_changes:
            logging.info("Callback was triggered by a change in the phrase-grid.")
        else:
            logging.info("Callback was not triggered by a change in the phrase-grid.")
            return dash.no_update
        
        # If the phrase-grid data was not the trigger, avoid further processing.
        if "phrase-grid.data" not in triggered_id:
            logging.info("Callback was not triggered by phrase-grid data change.")
            return dash.no_update  # This tells Dash not to update the output

        # Initialize lists to store block ids
        required_inclusion_blocks = []
        non_required_inclusion_blocks = []
        exclusion_blocks = []

        # Iterate through block ids to categorize them based on logic
        for block_id in block_ids:
            block_data = df_phrase_grid[df_phrase_grid['block_id'] == block_id]
            if block_data[block_data['phrase_operator'] == 'INCLUDE MATCHES'].shape[0] > 0 and block_data['block_combo_logic'].iloc[0]:
                required_inclusion_blocks.append(block_id)
            elif block_data[block_data['phrase_operator'] == 'INCLUDE MATCHES'].shape[0] > 0:
                non_required_inclusion_blocks.append(block_id)
            else:
                exclusion_blocks.append(block_id)

        # Create logic strings
        inclusion_str = ' ∩ '.join(required_inclusion_blocks)
        if non_required_inclusion_blocks:
            inclusion_str += ' U ' if inclusion_str else ''
            inclusion_str += ' U '.join(non_required_inclusion_blocks)

        exclusion_str = ' ⊄ '.join(exclusion_blocks)

        # Construct the final output string
        if inclusion_str and exclusion_str:
            return f"({inclusion_str}) ⊄ {exclusion_str}"
        elif inclusion_str:
            return f"{inclusion_str}"
        elif exclusion_str:
            return f"⊄ {exclusion_str}"
        else:
            return "No logic defined"

    except Exception as e:
        logging.error(f"An error occurred during processing: {str(e)}")
        return "An error occurred during processing"
