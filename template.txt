def generate_final_sql(dataframe, q_key_parameter):

    block_ids = dataframe['block_id'].unique().tolist()
    block_combo_logic = dataframe['block_combo_logic'].iloc[0]

    def generate_union_sql(inclusion_blocks):
        return "\n\nUNION ALL\n\n".join([f"SELECT * \nFROM {block}_transformed_results" for block in inclusion_blocks])

    def generate_intersection_cte(inclusion_blocks, exclusion_blocks):
        base_alias = inclusion_blocks[0]
        inclusion_joins = "\n".join([f"INNER JOIN {block}_transformed_results AS {block}\n\tON {base_alias}.r_id = {block}.r_id" for block in inclusion_blocks[1:]])
        exclusion_joins = "\n".join([f"LEFT JOIN {block}_transformed_results AS {block}\n\tON {base_alias}.r_id = {block}.r_id" for block in exclusion_blocks])
        exclusion_conditions = " AND ".join([f"{block}.r_id IS NULL" for block in exclusion_blocks])

        cte_sql = f"""
WITH intersection AS (
SELECT {base_alias}.r_id
FROM {base_alias}_transformed_results AS {base_alias}
{inclusion_joins}
{exclusion_joins}
WHERE 1=1
{(' AND ' + exclusion_conditions) if exclusion_conditions else ""}
GROUP BY {base_alias}.r_id
)
        """
        return cte_sql

    inclusion_blocks = []
    exclusion_blocks = []

    for block_id in block_ids:
        row = dataframe[dataframe['block_id'] == block_id].iloc[0]
        phrase_operator = row['phrase_operator']
        standalone_pg = row['standalone_pg']
        if phrase_operator == 'INCLUDE MATCHES':
            inclusion_blocks.append(block_id)
        elif standalone_pg:
            exclusion_blocks.append(block_id)

    inclusion_blocks = sorted(inclusion_blocks)
    exclusion_blocks = sorted(exclusion_blocks)

    # COMMENTS: NEW JOIN LOGIC FOR "ANY BLOCKS" AND NON-STANDALONE
    if block_combo_logic == "ALL BLOCKS":
        cte = generate_intersection_cte(inclusion_blocks, exclusion_blocks)
        join_sql = "INNER JOIN intersection AS T2 \n\tON T1.r_id = T2.r_id"
    elif block_combo_logic != "ALL BLOCKS":
        cte = ""
        non_standalone_blocks = [block for block in inclusion_blocks if block not in exclusion_blocks]
        join_sql_parts = [f"INNER JOIN {block}_transformed_results ON T1.r_id = {block}_transformed_results.r_id" for block in non_standalone_blocks]
        join_sql = "\n".join(join_sql_parts)
    else:
        cte = ""
        join_sql = "-- NO INTERSECTION TO JOIN"

    union_sql = generate_union_sql(inclusion_blocks)
    all_columns = ['T1.r_id', 'T1.block_id', 'T1.phrase_group_id', 'T1.pcd', 'T1.seq', 'T1.utterance']

    final_sql = f"""
CREATE OR REPLACE TEMPORARY TABLE {q_key_parameter} AS
{cte}
SELECT
  S.col1
, Z.col2
FROM (
    SELECT {', '.join(all_columns)}
    FROM (
    \n{union_sql}\n
    ) T1
    {join_sql}
    GROUP BY {', '.join(all_columns)}
) Z
INNER JOIN query_scope S
    ON Z.r_id = S.r_id
GROUP BY col1, col2
"""

    logging.info(f"Generated SQL:\n{final_sql}")
    return final_sql
